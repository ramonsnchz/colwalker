// Generated by gencpp from file flexi/flexi.msg
// DO NOT EDIT!


#ifndef FLEXI_MESSAGE_FLEXI_H
#define FLEXI_MESSAGE_FLEXI_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace flexi
{
template <class ContainerAllocator>
struct flexi_
{
  typedef flexi_<ContainerAllocator> Type;

  flexi_()
    : x(0)
    , x2(0)
    , x3(0)
    , x4(0)
    , x5(0)
    , x6(0)
    , x7(0)
    , x8(0)
    , x9(0)
    , x10(0)
    , x11(0)
    , x12(0)
    , x13(0)
    , x14(0)
    , x15(0)
    , x16(0)  {
    }
  flexi_(const ContainerAllocator& _alloc)
    : x(0)
    , x2(0)
    , x3(0)
    , x4(0)
    , x5(0)
    , x6(0)
    , x7(0)
    , x8(0)
    , x9(0)
    , x10(0)
    , x11(0)
    , x12(0)
    , x13(0)
    , x14(0)
    , x15(0)
    , x16(0)  {
  (void)_alloc;
    }



   typedef int32_t _x_type;
  _x_type x;

   typedef int32_t _x2_type;
  _x2_type x2;

   typedef int32_t _x3_type;
  _x3_type x3;

   typedef int32_t _x4_type;
  _x4_type x4;

   typedef int32_t _x5_type;
  _x5_type x5;

   typedef int32_t _x6_type;
  _x6_type x6;

   typedef int32_t _x7_type;
  _x7_type x7;

   typedef int32_t _x8_type;
  _x8_type x8;

   typedef int32_t _x9_type;
  _x9_type x9;

   typedef int32_t _x10_type;
  _x10_type x10;

   typedef int32_t _x11_type;
  _x11_type x11;

   typedef int32_t _x12_type;
  _x12_type x12;

   typedef int32_t _x13_type;
  _x13_type x13;

   typedef int32_t _x14_type;
  _x14_type x14;

   typedef int32_t _x15_type;
  _x15_type x15;

   typedef int32_t _x16_type;
  _x16_type x16;





  typedef boost::shared_ptr< ::flexi::flexi_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::flexi::flexi_<ContainerAllocator> const> ConstPtr;

}; // struct flexi_

typedef ::flexi::flexi_<std::allocator<void> > flexi;

typedef boost::shared_ptr< ::flexi::flexi > flexiPtr;
typedef boost::shared_ptr< ::flexi::flexi const> flexiConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::flexi::flexi_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::flexi::flexi_<ContainerAllocator> >::stream(s, "", v);
return s;
}

} // namespace flexi

namespace ros
{
namespace message_traits
{



// BOOLTRAITS {'IsFixedSize': True, 'IsMessage': True, 'HasHeader': False}
// {'flexi': ['/home/ramon/catkin_colwalker/src/flexi/msg'], 'std_msgs': ['/opt/ros/kinetic/share/std_msgs/cmake/../msg']}

// !!!!!!!!!!! ['__class__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_parsed_fields', 'constants', 'fields', 'full_name', 'has_header', 'header_present', 'names', 'package', 'parsed_fields', 'short_name', 'text', 'types']




template <class ContainerAllocator>
struct IsFixedSize< ::flexi::flexi_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::flexi::flexi_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::flexi::flexi_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::flexi::flexi_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::flexi::flexi_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::flexi::flexi_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::flexi::flexi_<ContainerAllocator> >
{
  static const char* value()
  {
    return "52823d3067d94d638e3ddecc62e7832b";
  }

  static const char* value(const ::flexi::flexi_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x52823d3067d94d63ULL;
  static const uint64_t static_value2 = 0x8e3ddecc62e7832bULL;
};

template<class ContainerAllocator>
struct DataType< ::flexi::flexi_<ContainerAllocator> >
{
  static const char* value()
  {
    return "flexi/flexi";
  }

  static const char* value(const ::flexi::flexi_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::flexi::flexi_<ContainerAllocator> >
{
  static const char* value()
  {
    return "int32 x\n\
int32 x2\n\
int32 x3\n\
int32 x4\n\
int32 x5\n\
int32 x6\n\
int32 x7\n\
int32 x8\n\
int32 x9\n\
int32 x10\n\
int32 x11\n\
int32 x12\n\
int32 x13\n\
int32 x14\n\
int32 x15\n\
int32 x16\n\
";
  }

  static const char* value(const ::flexi::flexi_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::flexi::flexi_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.x);
      stream.next(m.x2);
      stream.next(m.x3);
      stream.next(m.x4);
      stream.next(m.x5);
      stream.next(m.x6);
      stream.next(m.x7);
      stream.next(m.x8);
      stream.next(m.x9);
      stream.next(m.x10);
      stream.next(m.x11);
      stream.next(m.x12);
      stream.next(m.x13);
      stream.next(m.x14);
      stream.next(m.x15);
      stream.next(m.x16);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct flexi_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::flexi::flexi_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::flexi::flexi_<ContainerAllocator>& v)
  {
    s << indent << "x: ";
    Printer<int32_t>::stream(s, indent + "  ", v.x);
    s << indent << "x2: ";
    Printer<int32_t>::stream(s, indent + "  ", v.x2);
    s << indent << "x3: ";
    Printer<int32_t>::stream(s, indent + "  ", v.x3);
    s << indent << "x4: ";
    Printer<int32_t>::stream(s, indent + "  ", v.x4);
    s << indent << "x5: ";
    Printer<int32_t>::stream(s, indent + "  ", v.x5);
    s << indent << "x6: ";
    Printer<int32_t>::stream(s, indent + "  ", v.x6);
    s << indent << "x7: ";
    Printer<int32_t>::stream(s, indent + "  ", v.x7);
    s << indent << "x8: ";
    Printer<int32_t>::stream(s, indent + "  ", v.x8);
    s << indent << "x9: ";
    Printer<int32_t>::stream(s, indent + "  ", v.x9);
    s << indent << "x10: ";
    Printer<int32_t>::stream(s, indent + "  ", v.x10);
    s << indent << "x11: ";
    Printer<int32_t>::stream(s, indent + "  ", v.x11);
    s << indent << "x12: ";
    Printer<int32_t>::stream(s, indent + "  ", v.x12);
    s << indent << "x13: ";
    Printer<int32_t>::stream(s, indent + "  ", v.x13);
    s << indent << "x14: ";
    Printer<int32_t>::stream(s, indent + "  ", v.x14);
    s << indent << "x15: ";
    Printer<int32_t>::stream(s, indent + "  ", v.x15);
    s << indent << "x16: ";
    Printer<int32_t>::stream(s, indent + "  ", v.x16);
  }
};

} // namespace message_operations
} // namespace ros

#endif // FLEXI_MESSAGE_FLEXI_H
